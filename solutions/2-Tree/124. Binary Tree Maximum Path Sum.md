# 124. Binary Tree Maximum Path Sum

Given a **non-empty** binary tree, find the maximum path sum.

For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain **at least one node** and does not need to go through the root.

**Example 1:**

```
Input: [1,2,3]

       1
      / \
     2   3

Output: 6
```

**Example 2:**

```
Input: [-10,9,20,null,null,15,7]

   -10
   / \
  9  20
    /  \
   15   7

Output: 42
```



- 一开始理解的题意是选取和最大的节点组合，所以就分当前节点大于0和小于0两种情况来讨论，并且时刻更新maxVal值。

```c++
class Solution {

private:
    int maxVal = 0;
public:
    int maxPathSum(TreeNode* root) {
        maxVal = root->val;
        pathSum(root);
        return maxVal;
    }

    int pathSum(TreeNode* root) {
        if(!root) return 0;
        if(!root->left && !root->right) {
            maxVal = max(maxVal, root->val);
            return root->val;
        }
        int leftSum = root->left ? pathSum(root->left) : 0;
        int rightSum = root->right ? pathSum(root->right) : 0;
        if(root->val > 0) {
            int tmp = leftSum + rightSum + root->val;
            maxVal = max(maxVal, tmp);
            return tmp;
        }
        if(leftSum > -root->val || rightSum > -root->val){
            int tmp = root->val + (leftSum > -root->val ? leftSum : 0) + (rightSum > -root->val ? rightSum : 0);
            maxVal = max(maxVal, tmp);
            return tmp;
        }

        else return 0;
    }
};
```

- 直到看到了题目中的这句话：a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections.

  也就是说，题目要求的是一个路径，二叉树中的路径定义为一条直线，因此，对于下面这个二叉树，路径只能是9-1-20-15或者9-1-20-7，而不能是9-1-20-15-7

  ```
      1
     / \
    9  20
      /  \
     15   7
  ```

  

- 一种解法：

- 对每一个节点都计算它及其子树的最大贡献。

  贡献值 = 当前节点的值 + 左右子树中贡献值较大的那个

  同时在每一个节点计算的时候，都更新maxVal，不过不是用贡献值来更新，而是取当前节点+左右节点的贡献值，由于在计算贡献值的时候，小于0的部分都被排除了，因此是可以知己计算的。

```c++
class Solution {

private:
    int maxVal = INT_MIN;
public:
    int getGain(TreeNode* root) {
        if(!root) return 0;
        // 计算每个节点的贡献（贡献值=当前值+左右子节点中较大的那一个）

        int leftGain = max(getGain(root->left), 0);
        int rightGain = max(getGain(root->right), 0);
		
        int myGain = root->val + max(leftGain, rightGain);
        int myResult = root->val + leftGain + rightGain;
        // 更新最大值，这个最大值是包含当前节点的左右子节点的贡献值和当前节点值
        maxVal = max(maxVal, myResult);
        return myGain;
    }
    int maxPathSum(TreeNode* root) {
        getGain(root);
        return maxVal;
    }
};
```

