# 31. Next Permutation



Implement **next permutation**, which rearranges numbers into the lexicographically next greater permutation of numbers.

If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).

The replacement must be **in-place** and use only constant extra memory.

Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.

`1,2,3` → `1,3,2`
`3,2,1` → `1,2,3`
`1,1,5` → `1,5,1`

下一个排序可以这样理解，比如说，1,2,3构成一个整数为123，还是由这3个数组成，寻找比123更大的下一个数，当然就是132了。但是，像321这种本来就是最大的数的话，找下一个就是最小的数123了。

- 如果数字是递减的，那么它就是用这些数字排列所组成的最大的数，只需要将数组中的数字反转即可将原来这个最大的数变成最小的数

可以这样做，![img](https://pic.leetcode-cn.com/1df4ae7eb275ba4ab944521f99c84d782d17df804d5c15e249881bafcf106173-file_1555696082944)

1. 从后往前遍历，找到递减的第一个元素a[i-1]（上图中1,3,5,6,7是递增的，到4的时候就变成递减的第一个）
2. 再从后面找到刚好比a[i-1]大一点点的元素，并将这两个元素交换位置
3. 把从i开始（包含i）后面的所有元素反转

也就是从后往前找到第一个最小的元素，这样的话**没有对 $ a[i-1] $ 右侧的重新排列可以创建更大的排列**，**因为该子数组由数字按降序组成**。因此，我们需要重新排列$ a[i-1] $右边的数字，包括它自己。对于$a[i-1]$来说，把它替换成刚好比他大一点点的值，这样$a[i-1]$的**右侧依然是递减的顺序**。因为第$i-1$位已经变成刚好比原来值大一点点的数，因此，它后面的值变成最小的串，就可以获得字典序中的下一个值。



- 写代码的时候，可以先把大概的流程写下来，然后根据每一部分需要做的事情把具体代码补全。
- 本次写的时候发现有两个地方出错了，就是两个判断的位置的大于等号，写的时候还是没想清楚，当两个值相等的时候到底需不需要继续移动指针。

```c++
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int len = nums.size();
        // 从后往前遍历，找到第一个递减的值a[i-1]
        int i = len - 2;
        while(i >= 0 && nums[i] >= nums[i+1]) i--;
        // 找到a[i-1]后面比它大的最小值，并将它和a[i-1]交换位置
        if(i >= 0) {
            int j = i;
            while(j < len - 1) {
                if(nums[j] > nums[i] && nums[j+1] <= nums[i]) {
                    swap(nums[i], nums[j]);
                    break;
                }
                j++;
            }
            if(j == len - 1) swap(nums[i], nums[j]);
        }
        // 将a[i]~end的元素逆序
        i++;
        int j = len - 1;
        while(i < j) {
            swap(nums[i], nums[j]);
            i++, j--;
        }
    }
};
```

