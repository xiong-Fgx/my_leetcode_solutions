# 87. Scramble String

Given a string *s1*, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively.

Below is one possible representation of *s1* = `"great"`:

```
    great
   /    \
  gr    eat
 / \    /  \
g   r  e   at
           / \
          a   t
```

To scramble the string, we may choose any non-leaf node and swap its two children.

For example, if we choose the node `"gr"` and swap its two children, it produces a scrambled string `"rgeat"`.

```
    rgeat
   /    \
  rg    eat
 / \    /  \
r   g  e   at
           / \
          a   t
```

We say that `"rgeat"` is a scrambled string of `"great"`.

Similarly, if we continue to swap the children of nodes `"eat"` and `"at"`, it produces a scrambled string `"rgtae"`.

```
    rgtae
   /    \
  rg    tae
 / \    /  \
r   g  ta  e
       / \
      t   a
```

We say that `"rgtae"` is a scrambled string of `"great"`.

Given two strings *s1* and *s2* of the same length, determine if *s2* is a scrambled string of *s1*.

**Example 1:**

```
Input: s1 = "great", s2 = "rgeat"
Output: true
```

**Example 2:**

```
Input: s1 = "abcde", s2 = "caebd"
Output: false
```

---

## Solution

这道题的解法并不算复杂，主要是要理解题意，并不是只能从中点进行翻转，也就是说从第一个字符后面就进行旋转，也可以在中间进行旋转，可以在当前节点不旋转，也可以在当前节点旋转。

要快速判断能否通过旋转变得一样，有一些很简单的指标，比如两个字符串的长度不一样，那么肯定是不行的，如果两个字符串所包含的字符不一样，肯定也不行。这里提供一种非常好用的判定两个字符串是否包含相同的字符的方法：

- 首先可以使用map，将每一个出现过的字符进行索引，如果每一个字符出现的次数都相同，那么肯定是可以的

- 这里也可以通过另一种方法，将字符串按照字符顺序进行排序，排序后如果两个字符串是相同的，那么他们包含的字符肯定是相同的。

  ```c++
  string ss1(s1);
  string ss2(s2);
  sort(ss1.begin(), ss1.end());
  sort(ss2.begin(), ss2.end());
  if(ss1 == s2)
      return true;
  ```

因此整个题目的代码就很明了了。

```c++
class Solution {
public:
    bool isScramble(string s1, string s2) {
        if(s1 == s2) return true;
        int len1 = s1.size(), len2 = s2.size();
        if(len1 != len2) return false;
        string ss1(s1);
        string ss2(s2);
        sort(ss1.begin(), ss1.end());
        sort(ss2.begin(), ss2.end());
        if(ss1 != ss2) return false;
        for(int i = 1; i < len1; i++) {
            // 在当前节点处不旋转左右子树，只是正常分叉
            if(isScramble(s1.substr(0, i), s2.substr(0, i)) && isScramble(s1.substr(i), s2.substr(i)))
                return true;
            // 表示在当前节点处就进行旋转
            // 判断s1的前半段和s2的后半段，s1的后半段和s2的前半段是否都相等。
            if(isScramble(s1.substr(0, i), s2.substr(len2 - i, len2)) && isScramble(s1.substr(i, len1), s2.substr(0, len2 - i)))
                return true;
        }
        return false;
    }
};
```

